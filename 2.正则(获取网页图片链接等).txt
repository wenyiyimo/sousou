阅读此篇教程大概需要3分钟,需要上篇用到的知识,动手大概需要10分钟

获取网页源码后,如果网页内容为字符串格式,则需要正则匹配结果,本教程将使用javaScript中的 exec 函数,如果是json格式则更为简单,将于下一篇讲解

下面这一段需要了解一下,能看懂即可
exec语法:
RegExpObject.exec(string)
返回值:返回一个数组,未找到匹配,则返回值为null
说明：
如果 exec 找到了匹配的文本,则返回一个结果数组。否则,返回 null。
此数组的第 0 个元素是与正则表达式相匹配的文本,
第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本(如果有的话),
第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本(如果有的话),以此类推。
除了数组元素和 length 属性之外,exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。
我们可以看得出,在调用非全局的 RegExp 对象的 exec 方法时,返回的数组与调用方法 String.match() 返回的数组是相同的。
但是,当 RegExpObject 是一个全局正则表达式时,exec 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。
当 exec 找到了与表达式相匹配的文本时,在匹配后,它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。
这就是说,您可以通过反复调用 exec 方法来遍历字符串中的所有匹配文本。当 exec 再也找不到匹配的文本时,它将返回 null,并把 lastIndex 属性重置为 0。
重要事项: 如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串,就必须手动地把 lastIndex 属性重置为 0。

上面这一段比较复杂,如果看不懂也没关系,直接看例子:
//key是正则表达式,html为上篇教程获得的源码,匹配一次
async matchOnce(key, html) {
		try {
			let re = new RegExp(key, 'g')
			let t = re.exec(html);
			return {
				flag: true,
				data: t[1].trim(),
				msg: '匹配完成'
			}
		} catch (e) {
			return {
				flag: false,
				data: String(e),
				msg: '匹配失败'
			}
		}
	},
	// 匹配所有
	async matchAll(key, html) {
		try {
			let re = new RegExp(key, 'g')
			let t;
			let results = [];
			while ((t = re.exec(html)) != null) {
				results.push(t[1].replace(new RegExp("\\\\", "g"), "").trim());
			};
			return {
				flag: true,
				data: results,
				msg: '匹配完成'
			}
		} catch (e) {
			//TODO handle the exception
			return {
				flag: false,
				data: String(e),
				msg: '匹配失败'
			}
		}
	},
  
  
将这两个函数直接复制到上一篇中的http.js中
let http = {
	// 网络请求
	async get(url, header = {}) {
		return new Promise((resolve, reject) => {
			uni.request({
				url: url,
				method: 'GET',
				header: header,
				timeout: 10000, //设置超时时间为10秒
				success(response) {
					resolve(response.data);
				},
				fail(error) {
					reject(error)
				}
			})
		})
	},
	async matchOnce(key, html) {
		try {
			let re = new RegExp(key, 'g')
			let t = re.exec(html);
			return {
				flag: true,
				data: t[1].trim(),
				msg: '匹配完成'
			}
		} catch (e) {
			return {
				flag: false,
				data: String(e),
				msg: '匹配失败'
			}
		}
	},
	// 匹配所有
	async matchAll(key, html) {
		try {
			let re = new RegExp(key, 'g')
			let t;
			let results = [];
			while ((t = re.exec(html)) != null) {
				results.push(t[1].replace(new RegExp("\\\\", "g"), "").trim());
			};
			return {
				flag: true,
				data: results,
				msg: '匹配完成'
			}
		} catch (e) {
			//TODO handle the exception
			return {
				flag: false,
				data: String(e),
				msg: '匹配失败'
			}
		}
	},
}
export default http

接下来,我们来爬取一下任意一个网址的所有链接,修改index.vue,如下


